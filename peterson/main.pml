/* Именованные константы, как в C */
#define N 5

/* Нет дробных чисел, только bit, byte, short, int */

int leader = -1;
int I = 123;

/* Операторы (statements) бывают 2 типов: условия (condition) и присвоения
 * (assignment) */

/* Объявления и присвоения всегда выполнимы. Условия выполняются, когда
 * они истинны. Если процесс не может выполнить, то он зависает.
 */

/* Чтобы определить типы сообщений: mtype = {foo, bar, bah}. chan = [] of
 * {mtype, int}; chan ! bah(3) */

/* Можно было перечислить каналы так: chan src; chan sink */
/* Можно написать active proctype или active[N] ..., чтобы не создавать
 * процессы при помощи run */
proctype System(int id; chan src, sink)
{
    /* Локальные переменные, не видны в других процессах */
    bit passive = 0;
    int lid, fid, max = id;

    /* Имеется 2 оператора разделения операторов: ; и ->. Именно разделения, а
     * не завершения, поэтому после последнего оператора разделение не нужно.
     * Разницы нет, стрелочку используют, чтобы показать зависимость следующего
     * оператора от предыдущего.
     */

    /* Структура повторения. Кейсы определяются через ::. Первое условие в
     * в кейсе называется защитой (guard). Если защита не выполняется, то кейс
     * не будет выполняться. Если можно выполнить несколько кейсов, то один
     * выбирается недетерминированно. Если нельзя выполнить ни один из кейсов,
     * то структура блокируется. Чтобы завершить повторения, используется
     * break.
     */ 
    do
    :: (leader == -1) ->
        /* Структура выбора. Аналогична повторению, но выполняется один раз.
         * else выполняется, когда остальные кейсы недоступны.
         */
        if
        :: (passive != 1)
            /* ! чтобы записать в канал, ? чтобы прочитать. Аргументы
             * перечисляются через запятую. Если после ? стоят константы, то
             * сообщение извлекается, если соответствующие поля им равны. ??
             * чтобы извлечь первое подходящее сообщение.
             */

            sink ! max;
            src ? lid;
            sink ! lid;
            src ? fid;

            if
            :: (lid == max) -> leader = max;
            :: (lid > fid) && (lid > max) -> max = lid
            :: else -> passive = 1;
            fi

        :: else ->
            src ? lid;
            sink ! lid;
            src ? fid;
            sink ! fid;
            /* Вывод строки как в Си */
            printf("%d\n", leader);
        fi
    od
}

/* Начальный процесс, аналог main из Си */
init
{
    /* Через канал процессы передают друг другу сообщения. Канал работает как
     * очередь, где длина указывается в []. Если канал нулевой длины, то он
     * называется рандеву-портом. Рандеву-порты обеспечивают передачу через
     * рукопожатие, при котором отправитель ждет получателя. В {} определяется
     * структура сообщения (поля). len(mychan) чтобы получить длину. Также
     * доступны предикаты empty, full, nempty, nfull.
     */

    /* Определяем переходы между системами */
    chan trans[N] = [1] of {int};

    int count = 0;

    do
    :: (count != N) ->
        /* Оператор run создает новый процесс указанного типа (блокируется,
         * если слишком много процессов). Родительский процесс не может
         * завершиться раньше дочерних.
         */

        /* Процессы выполняются параллельно. Один из способов синхронизировать
         * процессы - использовать глобальную арбитр-переменную. Другой способ
         * - использовать атомарные последовательности atomic {}. Когда
         * атомарная последовательность выполняется, остальные процессы ждут.
         * Атомарность теряется, когда внутри последовательности блокируется
         * оператор.
         */

        run System((I + 1 + count) % N + 1,
                   trans[(N + count - 1) % N],
                   trans[(count + 1) % N]);
        /* Преинкремента нет */
        count++

    :: (count == N) -> break
    od
}

/* Описание свойства на языке LTL: сначала лидер не найден, затем он
 * определяется какой-нибудь системой и остается неизменным */

/* Предикаты можно определять в самом свойстве внутри {} */
#define found (leader == N)
ltl prop {!found U []found}

/* ! - отрицание;
 * [] - всегда, включая сейчас (G);
 * <> - сейчас или когда-нибудь (F);
 * p1 U p2 - p2 начинается, когда заканчивается p1 (p2 всегда, если p1 не
 * начиналось);
 * p1 W p2 - как U, но если p2 не начинается, то p1 всегда;
 */

/* skip - оператор, который ничего не делает;
 * eval - подставить константу вместо переменной;
 */ 
